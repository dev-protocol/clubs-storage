/* eslint-disable functional/no-return-void */
/* eslint-disable functional/no-promise-reject */
/* eslint-disable functional/no-expression-statements */
/* eslint-disable functional/no-conditional-statements */
import os from 'os'
import path from 'path'
import fs from 'fs/promises'
import { nanoid } from 'nanoid'
import { put } from '@vercel/blob'
import ffmpeg from 'fluent-ffmpeg'
import { Redis } from '@upstash/redis'
import type { APIRoute } from 'astro'
import ffpmegInstaller from '@ffmpeg-installer/ffmpeg'
import { hashMessage, recoverAddress, ZeroAddress } from 'ethers'
import {
	whenDefined,
	whenDefinedAll,
	whenNotError,
	whenNotErrorAll,
} from '@devprotocol/util-ts'

import { json } from 'utils/json'

export const POST: APIRoute = async ({ request, url }) => {
	const form = await request.formData()

	const props = whenDefinedAll(
		[url.searchParams.get('signature'), url.searchParams.get('message')],
		([signature, message]) => ({ signature, message }),
	)
	const ogFile =
		whenDefined(form.get('file'), (file) => file as File) ??
		new Error('File is missing.')

	const file = await whenNotError(ogFile, async (_file) => {
		const fileType = _file.type
		if (!fileType.includes('video')) {
			// If file type is not video, then don't convert it to mp4.
			return _file
		}

		// Define temporary file paths.
		const tempInputPath = path.join(
			os.tmpdir(),
			`input-${Date.now()}-${_file.name}`,
		)
		const tempOutputPath = path.join(os.tmpdir(), `output-${Date.now()}.mp4`)
		// Save the uploaded file to a temporary location.
		await fs.writeFile(tempInputPath, Buffer.from(await _file.arrayBuffer()))

		// Convert the video to mp4.
		await new Promise((resolve, reject) => {
			ffmpeg()
				.setFfmpegPath(ffpmegInstaller.path!)
				.input(tempInputPath)
				.output(tempOutputPath)
				.videoCodec('libx264')
				.audioCodec('aac')
				.outputOption('-movflags faststart')
				.format('mp4')
				.on('end', (_) => {
					console.log('Resolved', _)
					resolve(_)
				})
				.on('error', (err) => {
					console.error('FFmpeg error:', err.message)
					reject(err)
				})
				.run()
		})

		const outputBuffer = await fs.readFile(tempOutputPath)
		const newFile = new File([outputBuffer], `output-${Date.now()}.mp4`, {
			type: 'video/mp4',
		})

		// Clean up temporary files
		await Promise.all([fs.unlink(tempInputPath), fs.unlink(tempOutputPath)])
		return newFile
	})

	const eoa =
		whenDefined(props, ({ signature, message }) =>
			recoverAddress(hashMessage(message), signature),
		) ?? ZeroAddress

	const fileId = nanoid()
	const pathname = `${eoa}/${fileId}` // a random UID generated by Vercel Blob will be added after this.

	const blob = await whenNotError(file, (_file) =>
		put(pathname, _file, {
			access: 'public',
			multipart: true, // To upload large files successfully.
			contentType: _file.type,
		}),
	)

	const client = await whenNotError(
		new Redis({
			url: process.env.KV_REST_API_URL,
			token: process.env.KV_REST_API_TOKEN,
		}),
		async (_client) => {
			return _client
		},
	)

	const savedFileId = await whenNotErrorAll(
		[fileId, client, blob],
		async ([_fileId, _client, _blob]) => {
			return _client
				.set(_fileId, _blob.url)
				.then((res) => (res ? _fileId : new Error('Invalid res')))
				.catch((err) => new Error(err))
		},
	)

	return new Response(
		json({ blob, storageURL: `https://storage.clubs.place/${savedFileId}` }),
	)
}
