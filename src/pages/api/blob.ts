import { nanoid } from 'nanoid'
import { put } from '@vercel/blob'
import { Redis } from '@upstash/redis'
import type { APIRoute } from 'astro'
import { hashMessage, recoverAddress, ZeroAddress } from 'ethers'
import {
	whenDefined,
	whenDefinedAll,
	whenNotError,
	whenNotErrorAll,
} from '@devprotocol/util-ts'

import { cors, json } from 'utils/json'
import { putAsHls } from 'utils/hls'

export const POST: APIRoute = async ({ request, url }) => {
	const form = await request.formData()

	const props = whenDefinedAll(
		[url.searchParams.get('signature'), url.searchParams.get('message')],
		([signature, message]) => ({ signature, message }),
	)
	const options = {
		convertToHls: url.searchParams.get('convert') === 'hls',
	}
	const file =
		whenDefined(form.get('file'), (file) => file as File) ??
		new Error('File is missing.')


	const eoa =
		whenDefined(props, ({ signature, message }) =>
			recoverAddress(hashMessage(message), signature),
		) ?? ZeroAddress

	const fileId = nanoid()
	const pathname = `${eoa}/${fileId}` // a random UID generated by Vercel Blob will be added after this.

	const blob = await whenNotError(file, (_file) =>
		options.convertToHls && _file.type.includes('video')
			? putAsHls({ file: _file, pathname })
			: put(pathname, _file, {
					access: 'public',
					multipart: true, // To upload large files successfully.
					contentType: _file.type,
				}),
	)

	const client = await whenNotError(
		new Redis({
			url: process.env.KV_REST_API_URL,
			token: process.env.KV_REST_API_TOKEN,
		}),
		async (_client) => {
			return _client
		},
	)

	const savedFileId = await whenNotErrorAll(
		[fileId, client, blob],
		async ([_fileId, _client, _blob]) => {
			return _client
				.set(_fileId, _blob.url)
				.then((res) => (res ? _fileId : new Error('Invalid res')))
				.catch((err) => new Error(err))
		},
	)

	return new Response(
		json({ ...blob, storageURL: `https://storage.clubs.place/${savedFileId}` }),
		{ headers: { ...cors } },
	)
}
