import dotenv from 'dotenv'
import { nanoid } from 'nanoid'
import { put } from '@vercel/blob'
import { createClient } from 'redis'
import type { APIRoute } from 'astro'
import { hashMessage, recoverAddress, ZeroAddress } from 'ethers'
import {
	whenDefined,
	whenDefinedAll,
	whenNotError,
	whenNotErrorAll,
} from '@devprotocol/util-ts'

import { json } from 'utils/json'

// eslint-disable-next-line functional/no-expression-statements
dotenv.config()

export const POST: APIRoute = async ({ request, url }) => {
	const form = await request.formData()

	const props = whenDefinedAll(
		[url.searchParams.get('signature'), url.searchParams.get('message')],
		([signature, message]) => ({ signature, message }),
	)
	const file =
		whenDefined(form.get('file'), (file) => file) ??
		new Error('File is missing.')
	const eoa =
		whenDefined(props, ({ signature, message }) =>
			recoverAddress(hashMessage(message), signature),
		) ?? ZeroAddress

	const nanoId = nanoid()
	const pathname = `${eoa}/${nanoId}` // a random UID generated by Vercel Blob will be added after this.

	const blob = await whenNotError(file, (_file) =>
		put(pathname, _file, {
			access: 'public',
		}),
	)

	const client = await whenNotError(
		createClient({
			url: process.env.REDIS_URL,
			username: process.env.REDIS_USERNAME ?? '',
			password: process.env.REDIS_PASSWORD ?? '',
		}),
		async (_client) => {
			return _client.connect().catch((err) => new Error(err))
		},
	)

	const savedNanoId = await whenNotErrorAll(
		[nanoId, client, blob],
		async ([_nanoId, _client, _blob]) => {
			return _client
				.set(_nanoId, _blob.url)
				.then((res) => (res ? _nanoId : new Error('Invalid res')))
				.catch((err) => new Error(err))
		},
	)

	return new Response(json({ savedNanoId }))
}
