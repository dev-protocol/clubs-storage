/* eslint-disable functional/no-return-void */
/* eslint-disable functional/no-promise-reject */
/* eslint-disable functional/no-expression-statements */
/* eslint-disable functional/no-conditional-statements */

import os from 'os'
import path from 'path'
import fs from 'fs/promises'
import { nanoid } from 'nanoid'
import { put } from '@vercel/blob'
import ffmpeg from 'fluent-ffmpeg'
import { Redis } from '@upstash/redis'
import type { APIRoute } from 'astro'
import ffmpegPath from 'ffmpeg-static'
import { hashMessage, recoverAddress, ZeroAddress } from 'ethers'
import {
	whenDefined,
	whenDefinedAll,
	whenNotError,
	whenNotErrorAll,
} from '@devprotocol/util-ts'

import { json } from 'utils/json'

// Tell fluent-ffmpeg where it can find FFmpeg
ffmpeg.setFfmpegPath(ffmpegPath || '')

export const POST: APIRoute = async ({ request, url }) => {
	const form = await request.formData()

	const props = whenDefinedAll(
		[url.searchParams.get('signature'), url.searchParams.get('message')],
		([signature, message]) => ({ signature, message }),
	)
	const ogFile =
		whenDefined(form.get('file'), (file) => file as File) ??
		new Error('File is missing.')

	const file = await whenNotError(ogFile, async (_file) => {
		const fileType = _file.type
		if (!fileType.includes('video')) {
			// If file type is not video, then don't convert it to mp4.
			return _file
		}

		// Define temporary file paths.
		const tempInputPath = path.join(
			os.tmpdir(),
			`input-${Date.now()}-${_file.name}`,
		)
		const tempOutputPath = path.join(os.tmpdir(), `output-${Date.now()}.mp4`)
		// Save the uploaded file to a temporary location.
		await fs.writeFile(tempInputPath, Buffer.from(await _file.arrayBuffer()))
		// Convert the video to mp4.
		await new Promise((resolve, reject) => {
			ffmpeg(tempInputPath)
				.output(tempOutputPath) // Pipe the converted output to PassThrough
				.videoCodec('libx264') // Use H.264 codec
				.format('mp4') // Convert to MP4 format
				.on('end', (_) => {
					console.log('Resolved', _)
					resolve(_)
				})
				.on('error', (err) => {
					console.error('FFmpeg error:', err.message)
					reject(err)
				})
				.run()
		})

		const outputBuffer = await fs.readFile(tempOutputPath)
		// Clean up temporary files
		await Promise.all([fs.unlink(tempInputPath), fs.unlink(tempOutputPath)])

		return outputBuffer
	})

	const eoa =
		whenDefined(props, ({ signature, message }) =>
			recoverAddress(hashMessage(message), signature),
		) ?? ZeroAddress

	const nanoId = nanoid()
	const pathname = `${eoa}/${nanoId}` // a random UID generated by Vercel Blob will be added after this.

	const blob = await whenNotError(file, (_file) =>
		put(pathname, _file, {
			access: 'public',
			multipart: true, // To upload large files successfully.
			contentType: 'video/mp4',
		}),
	)

	const client = await whenNotError(
		new Redis({
			url: process.env.KV_REST_API_URL,
			token: process.env.KV_REST_API_TOKEN,
		}),
		async (_client) => {
			return _client
		},
	)

	const savedNanoId = await whenNotErrorAll(
		[nanoId, client, blob],
		async ([_nanoId, _client, _blob]) => {
			return _client
				.set(_nanoId, _blob.url)
				.then((res) => (res ? _nanoId : new Error('Invalid res')))
				.catch((err) => new Error(err))
		},
	)

	return new Response(json({ blob, savedNanoId }))
}
